"""""""""""""""""""""""""" Most important settings """"""""""""""""""""""""" {{{
filetype plugin on    "allow for autocmds to be run based on filetype
set nocompatible      "Don't do weird stuff for vi
set number            "turn on line numbers in the left columns
set formatoptions+=j  "Delete comment character when joining commented lines

" Enable syntax, and set a colorscheme. Don't do this twice
if !exists("colors_name")
  syntax enable       "allow for syntax highlighting and indenting
  colorscheme desert  "pretty colors
endif

" briefly show the matching bracket {[( when typing )]}
set showmatch matchtime=3

"""""""""""""""""""""""""" Better search/highlight """"""""""""""""""""""""" {{{
" highlight search (highlight matches)
set hlsearch
" incremental search (highlight as we type the search query)
set incsearch
" Clear highlighting for search terms
noremap <silent> <C-_> :nohlsearch<CR>
inoremap <silent> <C-_> <C-o>:nohlsearch<CR>
" If you set :nohlsearch but then source vimrc again, then the highlights will
" reappear. You must clear the @/ register to stop this.
noremap <silent> <Leader>/ :let @/ = ""<CR>

" Improvements to '*' - work in visual mode & don't go to the next instance
" This one is sweet: use star in visual mode to search for the selected text
" yank into register 0 --> forward search for the contents of register 0
" (Very nomagic, escape contents of 0 register before pasting).
vnoremap <silent> * "0y:let@/='\V<C-r>=escape(@0, '/\')<CR>'<CR>
nnoremap * *N
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}

""""""""""""""""""" Important commands from defaults.vim """"""""""""""""""" {{{
" allow backspacing over more things
set backspace=indent,eol,start

" CTRL-W in insert mode deletes a lot. Wse CTRL-G u to first break undo,
" so that you can undo CTRL-W after inserting a line break.
inoremap <C-W> <C-G>u<C-W>

" Multi-keystroke commands will be shown in bottom right.
set showcmd

" timeout on escape codes after 100 ms
set ttimeout ttimeoutlen=100

" Nicer tab'ing in command mode (wild
set wildmenu

" Default to giving me a lil more space to see context
set scrolloff=5
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}

" Multi-keystroke commands will not timeout Only cancel a partially given
" command manually (<C-c> or <ESC>)
set notimeout

" 1st tab:         Complete the longest match and bring up 'wildmenu'
" Additional tabs: Cycle through the menu
set wildmode=longest:full,full

" Use vim's system clipboard register ("*) instead of the unnamed register for
" yank/put/delete. This links these commands to the system clipboard
if !has('clipboard') && !has('xterm_clipboard')
  echom "[VIMRC] WARNING: Not compiled with clipboard support"
endif
set clipboard=unnamed
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
"""""""""""""""""""""""""" Less important settings """"""""""""""""""""""""" {{{
set display=lastline  "as much as possible of the last line will be displayed
set gdefault          "turn global flag on by default for :substitute
set history=1000      "the default is only 40.
set noshowmode        "don't show the mode (we use nice statuslines now!)
set noerrorbells      "disable error bells
set belloff=all       "disable bell for non-errors, too
set lazyredraw        "don't update the screen when doing macros
set updatetime=100    "let vim-gitgutter update faster
set sidescrolloff=4   "Min # of columns to keep to the left/right of the cursor
set splitbelow splitright "new splits open to the bottom or to the right
set autoread          "Autoload file changes. You can undo by pressing u
set pumheight=8       "set max popup menu height to 8
set tags+=tags;       "ctags is so helpful! And easy, too.
set indentexpr= "Turn off all indenting by default
set nojoinspaces      "don't put 2 spaces after [.!?] when using join command
set signcolumn=yes    "Show signs in the left columns
set whichwrap+=<,>,[,] "Have <Left> and <Right> go across lines
set foldlevel=3       " Don't fold most things by default
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
""""""""""""""""""""""""""""" Whitespace stuff """"""""""""""""""""""""""""" {{{
" Get fancy listchars if it’s supported
if (&termencoding ==# 'utf-8' || &encoding ==# 'utf-8') && version >= 700
  set listchars=tab:\¦›,space:⋅,eol:¬,nbsp:+,
  set fillchars=vert:\|,fold:\⋅,
  "set showbreak=↪.
  set showbreak=☞\ " "Leave this comment and extra whitespace
else
  set listchars=tab:X-,space:.,eol:$,nbsp:+,
  set fillchars=vert:\|,fold:\~
  set showbreak=->
endif

" Toggle displaying whitespace characters
nnoremap <Leader>l :let @/ = '\s$'<CR>:set list!<CR>

" Toggle hide/show of left columns
nnoremap <silent> <Leader>[ :call lib#toggleLeftColumns()<CR>

" Keep it clean
nnoremap <silent> <Leader>w :call lib#removeTrailingWhitespace('%')<CR>

" Update textwidth and ColorColumn at the same time
nnoremap <silent> <Leader>tw :<C-u>call lib#changeTextWidth(v:count)<CR>
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
""""""""""""""""""""""""""""""" Pretty colors """""""""""""""""""""""""""""" {{{
highlight Folded ctermbg=234 ctermfg=8

" Give fun colors to the left columns (and the ColorColumn)
highlight FoldColumn ctermbg=233 ctermfg=8
highlight SignColumn ctermbg=234 ctermfg=8
highlight ColorColumn ctermbg=233

" Toggle syntax highlighting
noremap <Leader>sy :call lib#toggleSyntax()<CR>
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
"""""""""""""""""""""""""""""""" Easier make """"""""""""""""""""""""""""""" {{{
" Easier make (write all before invoking the make command)
nnoremap <Leader>mm :wall<Bar>make!<CR>
nnoremap <Leader>mc :make check<CR>
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
"""""""""" convenience mappings (this stuff will mess with people) """"""""" {{{
" One keystroke to strip trailing whitespace on the current line and write in
" (almost) any mode
noremap  <C-f> <ESC>:call lib#removeTrailingWhitespace('.')<CR>:w<CR>
noremap! <C-f> <ESC>:call lib#removeTrailingWhitespace('.')<CR>:w<CR>

" <C-f> <C-g> will write and exit. Kinda emacs-y lol
nnoremap <C-g> :q<CR>

" Also... exit insert mode without having to move fingers.
inoremap jk <ESC>:call lib#removeTrailingWhitespace('.')<CR>

" When do I ever wanna hit 2 keys to execute one thought. Overwriting these
" isn't an issue as if I wanna operate on a range I can just use visual mode.
nnoremap D dd
nnoremap G Gzz
nnoremap zz ^zz
nnoremap zZ zz$
nnoremap < <<
nnoremap > >>

" Up/Down don't change relative line number
nnoremap <Up> <C-y>k
nnoremap <Down> <C-e>j

" Move up/down this virtual column until you hit non-whitespace
nnoremap gK ?\%<C-R>=virtcol(".")<CR>v\S<CR>
nnoremap gJ /\%<C-R>=virtcol(".")<CR>v\S<CR>

" Skip to current/next misspelled object and take the first fix
nnoremap Z= ge]s1z=
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
""""""""""""""""""""" Deal with buffest and tabs easier """""""""""""""""""" {{{
" Buffer close: remove buffer from memory
nnoremap <Leader>bc :bnext <Bar> bdelete #<CR>
" Remove buffer from memory AND close the window
nnoremap <Leader>BC :.bdelete<CR>

" Switch between buffers and tabs easier
nnoremap [b :bprevious<CR>
nnoremap ]b :bnext<CR>

" I like 'gr/gt' better than 'gT/gt'
nnoremap gr gT
" Remember <C-w>T moves a window to a new tab
" TODO is this reasonable? Create a new tab of the same thing
nnoremap gT :tabe<CR><C-O>
" Open a tag in a new tab. Useful for tracing execution across a stack.
nnoremap g<C-]> :tab tag <C-r>=expand("<cword>")<CR><CR>
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
"""""""""""""""""""""""""""" create text objects """"""""""""""""""""""""""" {{{
" Leaving this here cuz I might wanna do something actually useful with it
" eventually. I haven't, yet. But here's an atomic power that can't be hacked
" together easily
""" https://www.reddit.com/r/vim/comments/frlzt8/create_your_own_text_object/ ""
" Define a text object for the whole buffer
xnoremap <silent> wb GoggV
onoremap <silent> wb :<C-u>normal vie<CR>

" Easily define a text object for C-style commends
xnoremap <silent> a* [*o]*
onoremap <silent> a* :<C-u>normal va*V<CR>
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
""""""""""""""""""""""""""""""" Plugin config """""""""""""""""""""""""""""" {{{
""""""""""""""""""""""""""""""""" GitGutter """""""""""""""""""""""""""""""" {{{
" Tell vim-gitgutter to leave the color of my signcolumn alone
let g:gitgutter_override_sign_column_highlight = 0

" White sign, green background
highlight GitGutterAdd term=bold ctermfg=188 ctermbg=22
let g:gitgutter_sign_added = '>+'

" White sign, yellow background
highlight GitGutterChange term=bold ctermfg=188 ctermbg=3
let g:gitgutter_sign_modified = '>~'
let g:gitgutter_sign_modified_removed = '~_'

" Solid red box
highlight GitGutterDelete term=bold ctermfg=188 ctermbg=1
let g:gitgutter_sign_removed_first_line = '>‾'
let g:gitgutter_sign_removed = '>_'

" They're changesets more generally than hunks.
nmap [c <Plug>(GitGutterPrevHunk)
nmap ]c <Plug>(GitGutterNextHunk)

" They're Hunks not Chunks.
nmap [h <Plug>(GitGutterPrevHunk)
nmap ]h <Plug>(GitGutterNextHunk)
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
""""""""""""""""""""""""""""" xterm-color-table """""""""""""""""""""""""""" {{{
command! XTerm call TXTerm()
function! TXTerm()
  if !exists('g:XtermColorTableDefaultOpen')
    packadd xterm-color-table
  endif
  TXtermColorTable
endfunction
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
""""""""""""""""""""""""""""""""" fugitive """"""""""""""""""""""""""""""""" {{{
nnoremap <Leader>g :Git<CR>
nnoremap gb :Git blame<CR>
nnoremap gD :vertical Gdiffsplit dev<CR>
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
""""""""""""""""""""""""""""""""""" Misc """"""""""""""""""""""""""""""""""" {{{
" Maybe make one for each imporant wrapper? Maybe not lol. It would go into a
" plugin under the arisweedler pack. TODO
function! SurroundMap(surrounder)
  let l:it = a:surrounder
  execute printf('vnoremap %s c%s<C-r>"%s<C-c>', it, it, it)
  execute printf('nnoremap <Leader>%s "0di%s"_da%s"0P', it, it, it)
endfunction
call SurroundMap('`')
call SurroundMap('"')

" Make the grepprg git grep. This always searches from the root of the repo
" and ignores files that .gitignore specifies. It's a lil nicer.
let &grepprg="git grep --line-number"

" https://github.com/khuedoan/dotfiles/blob/97d5d7bb4f00374a19beb50eaa75a83a7d570b06/.vimrc#L48
" Change cursor shape in different modes (see :help cursor-shape)
let &t_EI = "\033[2 q" " NORMAL  █
let &t_SI = "\033[5 q" " INSERT  |

" temporary TODO fix this garbo
command! Dotfiles let g:gitgutter_git_executable = "git --git-dir=$HOME/dotfiles/ --work-tree=$HOME"
command! NDotfiles let g:gitgutter_git_executable = "git"

" Yank filename onto clipboard
nnoremap <Leader>% :let @*=expand('%:.')<CR>
nnoremap <Leader><Leader>% :let @*=expand('%:p')<CR>
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
"""""""""""""""""""""""""""""""" TODO stuff """""""""""""""""""""""""""""""" {{{
"""""""""""""""" Update files when changed in the background """"""""""""""" {{{
"This *would* be cool, if I had a use case for it. But I don't (for now)
"set autoread " Auto reload file if it has been changed outside of vim
"
"" Triger `autoread` when files changes on disk
"" https://unix.stackexchange.com/questions/149209/refresh-changed-content-of-file-opened-in-vim/383044#383044
"" https://vi.stackexchange.com/questions/13692/prevent-focusgained-autocmd-running-in-command-line-editing-mode
"autocmd FocusGained,BufEnter,CursorHold,CursorHoldI * if mode() != 'c' | checktime | endif
"
"" Notification after file change
"" https://vi.stackexchange.com/questions/13091/autocmd-event-for-autoread
"autocmd FileChangedShellPost *
"\ echohl WarningMsg | echo "File changed on disk. Buffer reloaded." | echohl None
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
""""""""""""""""""""""""""""""""" foldtext """"""""""""""""""""""""""""""""" {{{
" `help foldtext`
" Reference: http://dhruvasagar.com/2013/03/28/vim-better-foldtext
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
""""""""""""""""""""""""""""""""" Cfilter better """"""""""""""""""""""""""""""""" {{{
"" Put this is my own plugin. idk where I could fork it?
"" cfilter.vim: Plugin to filter entries from a quickfix/location list
"" Last Change: Aug 23, 2018
"" Maintainer: Yegappan Lakshmanan (yegappan AT yahoo DOT com)
"" Version: 1.1
""
"" Commands to filter the quickfix list:
""   :Cfilter[!] /{pat}/
""       Create a new quickfix list from entries matching {pat} in the current
""       quickfix list. Both the file name and the text of the entries are
""       matched against {pat}. If ! is supplied, then entries not matching
""       {pat} are used. The pattern can be optionally enclosed using one of
""       the following characters: ', ", /. If the pattern is empty, then the
""       last used search pattern is used.
""   :Lfilter[!] /{pat}/
""       Same as :Cfilter but operates on the current location list.
""
"if exists("loaded_cfilter")
"    finish
"endif
"let loaded_cfilter = 1
"
"func s:Qf_filter(qf, searchpat, bang)
"    if a:qf
"	let Xgetlist = function('getqflist')
"	let Xsetlist = function('setqflist')
"	let cmd = ':Cfilter' . a:bang
"    else
"	let Xgetlist = function('getloclist', [0])
"	let Xsetlist = function('setloclist', [0])
"	let cmd = ':Lfilter' . a:bang
"    endif
"
"    let firstchar = a:searchpat[0]
"    let lastchar = a:searchpat[-1:]
"    if firstchar == lastchar &&
"		\ (firstchar == '/' || firstchar == '"' || firstchar == "'")
"	let pat = a:searchpat[1:-2]
"	if pat == ''
"	    " Use the last search pattern
"	    let pat = @/
"	endif
"    else
"	let pat = a:searchpat
"    endif
"
"    if pat == ''
"	return
"    endif
"
"    if a:bang == '!'
"	let cond = 'v:val.text !~# pat && bufname(v:val.bufnr) !~# pat'
"    else
"	let cond = 'v:val.text =~# pat || bufname(v:val.bufnr) =~# pat'
"    endif
"
"    let items = filter(Xgetlist(), cond)
"    let title = cmd . ' /' . pat . '/'
"    call Xsetlist([], ' ', {'title' : title, 'items' : items})
"endfunc
"
"com! -nargs=+ -bang Cfilter call s:Qf_filter(1, <q-args>, <q-bang>)
"com! -nargs=+ -bang Lfilter call s:Qf_filter(0, <q-args>, <q-bang>)
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" }}}
